{
  "openapi": "3.0.0",
  "info": {
    "title": "Workflow Service",
    "description": "Workflow orchestration service. Register DAG workflows once, execute them by name with runtime inputs.\n\n## Quick Start\n\n**Step 1 — Deploy your workflows (once, at app startup):**\n```\nPUT /workflows/deploy\n{ \"appId\": \"my-app\", \"workflows\": [{ \"name\": \"my-flow\", \"dag\": { ... } }] }\n```\nThis is idempotent — safe to call on every cold start.\n\n**Step 2 — Execute by name (each time an event occurs):**\n```\nPOST /workflows/by-name/my-flow/execute\n{ \"appId\": \"my-app\", \"inputs\": { \"email\": \"user@example.com\" } }\n```\nReturns a run ID. Poll `GET /workflow-runs/{id}` for status and result.\n\n## DAG Format\n\nA DAG has `nodes` (steps) and `edges` (execution order).\n\n**Recommended node type: `http.call`** — calls any microservice by name:\n```json\n{\n  \"id\": \"create-user\",\n  \"type\": \"http.call\",\n  \"config\": { \"service\": \"client\", \"method\": \"POST\", \"path\": \"/users\" },\n  \"inputMapping\": { \"body\": \"$ref:flow_input.userData\" }\n}\n```\nThe service name maps to env vars `{NAME}_SERVICE_URL` and `{NAME}_SERVICE_API_KEY`.\nTo discover available services and their endpoints, use the API Registry.\n\n## Input Mapping ($ref syntax)\n\nUse `inputMapping` to pass data between nodes:\n- `$ref:flow_input.field` — from the workflow execution inputs\n- `$ref:node-id.output.field` — from a previous node's output\n\n## Features\n\n- Automatic retries (3 attempts, 5s apart) on each node\n- Async execution with status polling\n- Topological ordering — nodes run in dependency order\n- Native constructs: `wait` (delay), `condition` (branching), `for-each` (loops)\n\n## Per-App Secrets (BYOK)\n\nSome services (e.g. Stripe) require per-app API keys. **Never pass secrets as workflow inputs.**\nInstead, use the **key-service** app-keys system:\n\n**1. Register the key once (at app startup via `instrumentation.ts`):**\n```\nPOST key-service /internal/app-keys\n{ \"appId\": \"my-app\", \"provider\": \"stripe\", \"apiKey\": \"sk_live_xxx\" }\n```\n\n**2. Pass `appId` (not the secret) in your workflow inputs:**\n```\nPOST /workflows/by-name/create-course/execute\n{ \"appId\": \"my-app\", \"inputs\": { \"courseName\": \"My Course\", \"price\": 99 } }\n```\n\n**3. The downstream service resolves the key itself:**\nThe service (e.g. stripe-service) receives `appId`, calls key-service\n`GET /internal/app-keys/stripe/decrypt?appId=my-app` to get the decrypted key.\nNo secret ever transits through the workflow.\n\n## Setup Pattern (Next.js `instrumentation.ts`)\n\nPut all one-time setup in your app's `instrumentation.ts`. Both operations are idempotent (upsert):\n```typescript\nexport async function register() {\n  // Register per-app secrets\n  await fetch(`${KEY_SERVICE_URL}/internal/app-keys`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\", \"x-api-key\": KEY_SERVICE_API_KEY },\n    body: JSON.stringify({ appId: \"my-app\", provider: \"stripe\", apiKey: STRIPE_SECRET_KEY }),\n  });\n  // Deploy workflows\n  await fetch(`${WORKFLOW_SERVICE_URL}/workflows/deploy`, {\n    method: \"PUT\",\n    headers: { \"Content-Type\": \"application/json\", \"x-api-key\": WORKFLOW_SERVICE_API_KEY },\n    body: JSON.stringify({ appId: \"my-app\", workflows: [{ name: \"my-flow\", dag: { ... } }] }),\n  });\n}\n```",
    "version": "1.0.0"
  },
  "servers": [
    {
      "url": "https://windmill.mcpfactory.org"
    }
  ],
  "components": {
    "securitySchemes": {
      "apiKey": {
        "type": "apiKey",
        "in": "header",
        "name": "x-api-key"
      }
    },
    "schemas": {
      "HealthResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string"
          },
          "service": {
            "type": "string"
          },
          "windmill": {
            "type": "string"
          },
          "db": {
            "type": "string"
          }
        },
        "required": [
          "status",
          "service"
        ]
      },
      "WorkflowCategory": {
        "type": "string",
        "enum": [
          "sales",
          "pr"
        ],
        "description": "Workflow category."
      },
      "WorkflowChannel": {
        "type": "string",
        "enum": [
          "email"
        ],
        "description": "Workflow distribution channel."
      },
      "WorkflowAudienceType": {
        "type": "string",
        "enum": [
          "cold-outreach"
        ],
        "description": "Workflow audience type."
      },
      "WorkflowResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Workflow UUID. Not needed for execution — use name + appId instead."
          },
          "appId": {
            "type": "string",
            "description": "Application identifier."
          },
          "orgId": {
            "type": "string",
            "description": "Organization ID."
          },
          "brandId": {
            "type": "string",
            "nullable": true
          },
          "campaignId": {
            "type": "string",
            "nullable": true
          },
          "subrequestId": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Workflow name. Use this with appId to execute via /workflows/by-name/{name}/execute."
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable display name. Falls back to name if not set."
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "category": {
            "$ref": "#/components/schemas/WorkflowCategory"
          },
          "channel": {
            "$ref": "#/components/schemas/WorkflowChannel"
          },
          "audienceType": {
            "$ref": "#/components/schemas/WorkflowAudienceType"
          },
          "signature": {
            "type": "string",
            "description": "Deterministic SHA-256 hash of the canonical DAG JSON. Changes when any node, edge, or config changes."
          },
          "signatureName": {
            "type": "string",
            "description": "Human-readable name for this signature (e.g. 'Sequoia'). Used to distinguish workflow variants within the same category/channel/audienceType."
          },
          "dag": {
            "nullable": true,
            "description": "The DAG definition as submitted."
          },
          "windmillFlowPath": {
            "type": "string",
            "nullable": true,
            "description": "Internal Windmill flow path (managed automatically)."
          },
          "windmillWorkspace": {
            "type": "string",
            "description": "Windmill workspace (managed automatically)."
          },
          "createdAt": {
            "type": "string"
          },
          "updatedAt": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "appId",
          "orgId",
          "brandId",
          "campaignId",
          "subrequestId",
          "name",
          "displayName",
          "description",
          "category",
          "channel",
          "audienceType",
          "signature",
          "signatureName",
          "windmillFlowPath",
          "windmillWorkspace",
          "createdAt",
          "updatedAt"
        ]
      },
      "ErrorResponse": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string"
          },
          "details": {
            "nullable": true
          }
        },
        "required": [
          "error"
        ]
      },
      "DAGNode": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 1,
            "description": "Unique identifier for this node within the DAG. Used in edges and $ref input mappings."
          },
          "type": {
            "type": "string",
            "minLength": 1,
            "description": "Node type. Use \"http.call\" to call any microservice (recommended), or a specific node type. http.call config requires: service (name, e.g. \"stripe\"), method (HTTP verb), path (endpoint path). Native flow control types: \"condition\" — if/then/else branching (uses Windmill branchone). Outgoing edges with 'condition' define branches; nodes downstream of a conditional edge are nested inside that branch. Outgoing edges without 'condition' define after-branch steps that always execute. \"wait\" — sleep/delay. \"for-each\" — loop over items (body nodes are nested inside the loop). Legacy named types: stripe.createProduct, client.createUser, transactional-email.send."
          },
          "config": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Static parameters passed to the node. For http.call: { service, method, path, body?, query?, headers? }. For wait: { seconds }. For for-each: { iterator, parallel?, skipFailures? }. Each key becomes a direct parameter of the underlying script. Special config keys (stripped before passing to script): retries (number) — override default retry count; validateResponse ({ field, equals }) — throw error if response[field] !== equals, triggers onError handler; stopAfterIf (string) — native Windmill stop_after_if. JS expression evaluated after step completes using 'result' variable, stops the entire flow gracefully (no onError, no subsequent steps) when true. Example: \"result.found == false\". For conditional branching (run some steps but not others), use a \"condition\" node instead; skipIf (string) — native Windmill skip_if. JS expression evaluated before this step runs, skips only this step when true. Can reference previous results via results.<module_id>. Example: \"results.fetch_lead.found == false\". For multi-step skipping, prefer a \"condition\" node."
          },
          "inputMapping": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Dynamic input references using $ref syntax. Use \"$ref:flow_input.fieldName\" for workflow execution inputs, or \"$ref:node-id.output.fieldName\" for a previous node's output. Keys in inputMapping override same-named keys in config."
          },
          "retries": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of retry attempts on failure. Defaults to 3 if omitted. Set to 0 for non-idempotent operations (e.g., sending emails, consuming queue items) to prevent duplicates."
          }
        },
        "required": [
          "id",
          "type"
        ]
      },
      "DAGEdge": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "minLength": 1,
            "description": "Source node ID — this node runs first."
          },
          "to": {
            "type": "string",
            "minLength": 1,
            "description": "Target node ID — runs after the source completes."
          },
          "condition": {
            "type": "string",
            "description": "JavaScript expression for conditional branching. Only used when source node is type \"condition\". Edges WITH condition: target node (and its chain) are nested inside that branch — they only execute when the condition is true. Edges WITHOUT condition from a condition node: target is an after-branch step that always executes. Expressions can reference previous results (results.<module_id>.<field>) or flow_input. Example: \"results.fetch_lead.found == true\""
          }
        },
        "required": [
          "from",
          "to"
        ]
      },
      "DAG": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DAGNode"
            },
            "minItems": 1,
            "description": "The steps of the workflow. Must contain at least one node."
          },
          "edges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DAGEdge"
            },
            "description": "Execution order between nodes. Empty array for single-node workflows."
          },
          "onError": {
            "type": "string",
            "description": "Node ID of an error handler that runs when any node in the DAG fails (including validateResponse failures). Auto-injected parameters (available as script params, no inputMapping needed): failedNodeId (string) — the module ID of the step that failed; errorMessage (string) — the error message text. Can also access outputs from previously completed nodes via $ref syntax. Use this to call end-run with success: false. Tip: check errorMessage to distinguish expected stops (e.g. 'validation failed: expected found=true') from real errors."
          }
        },
        "required": [
          "nodes",
          "edges"
        ]
      },
      "CreateWorkflowRequest": {
        "type": "object",
        "properties": {
          "appId": {
            "type": "string",
            "minLength": 1,
            "description": "Application identifier. Workflows are scoped to appId."
          },
          "orgId": {
            "type": "string",
            "minLength": 1,
            "description": "Organization ID that owns this workflow."
          },
          "brandId": {
            "type": "string",
            "description": "Optional brand ID for scoping."
          },
          "campaignId": {
            "type": "string",
            "description": "Optional campaign ID for scoping."
          },
          "subrequestId": {
            "type": "string",
            "description": "Optional subrequest ID for cost tracking."
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "description": "Workflow name. Must be unique within the appId. Used to execute by name later."
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of what this workflow does."
          },
          "category": {
            "$ref": "#/components/schemas/WorkflowCategory"
          },
          "channel": {
            "$ref": "#/components/schemas/WorkflowChannel"
          },
          "audienceType": {
            "$ref": "#/components/schemas/WorkflowAudienceType"
          },
          "dag": {
            "$ref": "#/components/schemas/DAG"
          }
        },
        "required": [
          "appId",
          "orgId",
          "name",
          "category",
          "channel",
          "audienceType",
          "dag"
        ]
      },
      "ServiceEndpoint": {
        "type": "object",
        "properties": {
          "service": {
            "type": "string",
            "description": "Service name (e.g. 'apollo', 'stripe')."
          },
          "method": {
            "type": "string",
            "description": "HTTP method (e.g. 'POST', 'GET')."
          },
          "path": {
            "type": "string",
            "description": "Endpoint path (e.g. '/leads/search')."
          }
        },
        "required": [
          "service",
          "method",
          "path"
        ]
      },
      "ProviderRequirementsResponse": {
        "type": "object",
        "properties": {
          "endpoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ServiceEndpoint"
            },
            "description": "The http.call endpoints extracted from the workflow DAG."
          },
          "requirements": {
            "type": "array",
            "items": {
              "nullable": true
            },
            "description": "Provider requirements returned by key-service."
          },
          "providers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Unique provider names required by this workflow (e.g. ['apollo', 'firecrawl'])."
          }
        },
        "required": [
          "endpoints",
          "requirements",
          "providers"
        ]
      },
      "UpdateWorkflowRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1
          },
          "description": {
            "type": "string"
          },
          "dag": {
            "$ref": "#/components/schemas/DAG"
          }
        }
      },
      "ValidationResult": {
        "type": "object",
        "properties": {
          "valid": {
            "type": "boolean"
          },
          "errors": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "field": {
                  "type": "string"
                },
                "message": {
                  "type": "string"
                }
              },
              "required": [
                "field",
                "message"
              ]
            }
          }
        },
        "required": [
          "valid"
        ]
      },
      "WorkflowRunResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Run UUID. Use this to poll status via GET /workflow-runs/{id}."
          },
          "workflowId": {
            "type": "string",
            "nullable": true,
            "format": "uuid"
          },
          "orgId": {
            "type": "string"
          },
          "campaignId": {
            "type": "string",
            "nullable": true
          },
          "subrequestId": {
            "type": "string",
            "nullable": true
          },
          "runId": {
            "type": "string",
            "nullable": true,
            "description": "External run ID (if provided at execution time)."
          },
          "windmillJobId": {
            "type": "string",
            "nullable": true,
            "description": "Internal Windmill job ID (managed automatically)."
          },
          "windmillWorkspace": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "description": "Run status: queued, running, completed, failed, or cancelled."
          },
          "inputs": {
            "nullable": true,
            "description": "The inputs that were passed at execution time."
          },
          "result": {
            "nullable": true,
            "description": "Workflow result (available when status is completed). Contains the output of the last node."
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message (available when status is failed)."
          },
          "startedAt": {
            "type": "string",
            "nullable": true
          },
          "completedAt": {
            "type": "string",
            "nullable": true
          },
          "createdAt": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "workflowId",
          "orgId",
          "campaignId",
          "subrequestId",
          "runId",
          "windmillJobId",
          "windmillWorkspace",
          "status",
          "error",
          "startedAt",
          "completedAt",
          "createdAt"
        ]
      },
      "ExecuteWorkflowRequest": {
        "type": "object",
        "properties": {
          "appId": {
            "type": "string",
            "description": "App ID override. If not provided, falls back to the workflow's stored appId."
          },
          "inputs": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Runtime inputs for the workflow. Accessible in nodes via $ref:flow_input.fieldName."
          },
          "runId": {
            "type": "string",
            "description": "Optional external run ID for cost tracking via runs-service."
          }
        }
      },
      "WorkflowRunDebugResponse": {
        "type": "object",
        "properties": {
          "runId": {
            "type": "string",
            "format": "uuid"
          },
          "windmillJobId": {
            "type": "string"
          },
          "status": {
            "type": "string"
          },
          "flowStatus": {
            "nullable": true,
            "description": "Windmill flow_status object. Contains per-module execution details including resolved inputs, outputs, and timing for each step in the flow."
          },
          "result": {
            "nullable": true,
            "description": "Final flow result."
          }
        },
        "required": [
          "runId",
          "windmillJobId",
          "status"
        ]
      },
      "DeployWorkflowResult": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Auto-generated workflow name: {category}-{channel}-{audienceType}-{signatureName}."
          },
          "category": {
            "$ref": "#/components/schemas/WorkflowCategory"
          },
          "channel": {
            "$ref": "#/components/schemas/WorkflowChannel"
          },
          "audienceType": {
            "$ref": "#/components/schemas/WorkflowAudienceType"
          },
          "signature": {
            "type": "string",
            "description": "SHA-256 hash of the canonical DAG JSON."
          },
          "signatureName": {
            "type": "string",
            "description": "Human-readable name for this DAG variant (auto-generated by workflow-service)."
          },
          "action": {
            "type": "string",
            "enum": [
              "created",
              "updated"
            ]
          }
        },
        "required": [
          "id",
          "name",
          "category",
          "channel",
          "audienceType",
          "signature",
          "signatureName",
          "action"
        ]
      },
      "DeployWorkflowsResponse": {
        "type": "object",
        "properties": {
          "workflows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeployWorkflowResult"
            }
          }
        },
        "required": [
          "workflows"
        ]
      },
      "DeployWorkflowItem": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "Human-readable description."
          },
          "category": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowCategory"
              },
              {
                "description": "Workflow category. Required — used to build the workflow name."
              }
            ]
          },
          "channel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowChannel"
              },
              {
                "description": "Workflow distribution channel. Required — used to build the workflow name."
              }
            ]
          },
          "audienceType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowAudienceType"
              },
              {
                "description": "Workflow audience type. Required — used to build the workflow name."
              }
            ]
          },
          "dag": {
            "$ref": "#/components/schemas/DAG"
          }
        },
        "required": [
          "category",
          "channel",
          "audienceType",
          "dag"
        ]
      },
      "DeployWorkflowsRequest": {
        "type": "object",
        "properties": {
          "appId": {
            "type": "string",
            "minLength": 1,
            "description": "Your application identifier. Workflows are scoped to (appId + signature). Use the same appId when executing. This is idempotent — deploying the same DAG updates the existing workflow."
          },
          "orgId": {
            "type": "string",
            "minLength": 1,
            "description": "Organization ID that owns these workflows. If omitted, falls back to appId for backward compatibility."
          },
          "workflows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeployWorkflowItem"
            },
            "minItems": 1,
            "description": "The workflows to deploy."
          }
        },
        "required": [
          "appId",
          "workflows"
        ]
      },
      "GenerateWorkflowResponse": {
        "type": "object",
        "properties": {
          "workflow": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DeployWorkflowResult"
              },
              {
                "description": "The deployed workflow metadata."
              }
            ]
          },
          "dag": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DAG"
              },
              {
                "description": "The generated DAG definition."
              }
            ]
          },
          "category": {
            "$ref": "#/components/schemas/WorkflowCategory"
          },
          "channel": {
            "$ref": "#/components/schemas/WorkflowChannel"
          },
          "audienceType": {
            "$ref": "#/components/schemas/WorkflowAudienceType"
          },
          "generatedDescription": {
            "type": "string",
            "description": "LLM-generated description of what this workflow does."
          }
        },
        "required": [
          "workflow",
          "dag",
          "category",
          "channel",
          "audienceType",
          "generatedDescription"
        ]
      },
      "KeySource": {
        "type": "string",
        "enum": [
          "app",
          "byok"
        ],
        "description": "Required. Where to resolve the Anthropic API key: \"app\" or \"byok\"."
      },
      "GenerateWorkflowHints": {
        "type": "object",
        "properties": {
          "services": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Scope generation to these services. Reduces prompt size and improves accuracy."
          },
          "nodeTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Suggest specific node types for the LLM to use."
          },
          "expectedInputs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Expected flow_input field names (e.g. campaignId, email)."
          }
        },
        "description": "Optional hints to guide generation."
      },
      "GenerateWorkflowRequest": {
        "type": "object",
        "properties": {
          "appId": {
            "type": "string",
            "minLength": 1,
            "description": "Application identifier. The generated workflow will be deployed under this appId."
          },
          "orgId": {
            "type": "string",
            "minLength": 1,
            "description": "Organization ID."
          },
          "keySource": {
            "$ref": "#/components/schemas/KeySource"
          },
          "description": {
            "type": "string",
            "minLength": 10,
            "description": "Natural language description of the desired workflow. Be specific about the steps, services, and data flow."
          },
          "hints": {
            "$ref": "#/components/schemas/GenerateWorkflowHints"
          }
        },
        "required": [
          "appId",
          "orgId",
          "keySource",
          "description"
        ]
      },
      "BestWorkflowStats": {
        "type": "object",
        "properties": {
          "totalCostInUsdCents": {
            "type": "number",
            "description": "Total cost across all completed runs of this workflow."
          },
          "totalOutcomes": {
            "type": "number",
            "description": "Total replies or clicks (depending on objective) across all runs."
          },
          "costPerOutcome": {
            "type": "number",
            "nullable": true,
            "description": "Cost per reply or cost per click in USD cents. Null if no outcomes yet."
          },
          "completedRuns": {
            "type": "number",
            "description": "Number of completed runs used in the calculation."
          }
        },
        "required": [
          "totalCostInUsdCents",
          "totalOutcomes",
          "costPerOutcome",
          "completedRuns"
        ],
        "description": "Aggregated performance stats for this workflow."
      },
      "BestWorkflowResponse": {
        "type": "object",
        "properties": {
          "workflow": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "name": {
                "type": "string"
              },
              "category": {
                "$ref": "#/components/schemas/WorkflowCategory"
              },
              "channel": {
                "$ref": "#/components/schemas/WorkflowChannel"
              },
              "audienceType": {
                "$ref": "#/components/schemas/WorkflowAudienceType"
              },
              "signature": {
                "type": "string"
              },
              "signatureName": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "name",
              "category",
              "channel",
              "audienceType",
              "signature",
              "signatureName"
            ],
            "description": "The best-performing workflow metadata."
          },
          "dag": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DAG"
              },
              {
                "description": "The DAG definition of the best workflow."
              }
            ]
          },
          "stats": {
            "$ref": "#/components/schemas/BestWorkflowStats"
          }
        },
        "required": [
          "workflow",
          "dag",
          "stats"
        ]
      },
      "BestWorkflowObjective": {
        "type": "string",
        "enum": [
          "replies",
          "clicks"
        ],
        "description": "Which metric to optimize for."
      },
      "ExecuteByNameRequest": {
        "type": "object",
        "properties": {
          "appId": {
            "type": "string",
            "minLength": 1,
            "description": "Must match the appId used during deploy."
          },
          "orgId": {
            "type": "string",
            "description": "Organization ID for this execution (overrides workflow's orgId if set)."
          },
          "inputs": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Runtime inputs for the workflow. Accessible in nodes via $ref:flow_input.fieldName."
          },
          "runId": {
            "type": "string",
            "description": "Optional external run ID for cost tracking via runs-service."
          }
        },
        "required": [
          "appId"
        ]
      }
    },
    "parameters": {}
  },
  "paths": {
    "/health": {
      "get": {
        "summary": "Health check",
        "tags": [
          "Health"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflows": {
      "post": {
        "summary": "Create a new workflow",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateWorkflowRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Workflow created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowResponse"
                }
              }
            }
          },
          "400": {
            "description": "Validation error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "get": {
        "summary": "List workflows",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string"
            },
            "required": true,
            "name": "orgId",
            "in": "query"
          },
          {
            "schema": {
              "type": "string"
            },
            "required": false,
            "name": "appId",
            "in": "query"
          },
          {
            "schema": {
              "type": "string"
            },
            "required": false,
            "name": "brandId",
            "in": "query"
          },
          {
            "schema": {
              "type": "string"
            },
            "required": false,
            "name": "campaignId",
            "in": "query"
          },
          {
            "schema": {
              "$ref": "#/components/schemas/WorkflowCategory"
            },
            "required": false,
            "description": "Workflow category.",
            "name": "category",
            "in": "query"
          },
          {
            "schema": {
              "$ref": "#/components/schemas/WorkflowChannel"
            },
            "required": false,
            "description": "Workflow distribution channel.",
            "name": "channel",
            "in": "query"
          },
          {
            "schema": {
              "$ref": "#/components/schemas/WorkflowAudienceType"
            },
            "required": false,
            "description": "Workflow audience type.",
            "name": "audienceType",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "List of workflows",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "workflows": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/WorkflowResponse"
                      }
                    }
                  },
                  "required": [
                    "workflows"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/workflows/{id}": {
      "get": {
        "summary": "Get a workflow",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Workflow found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update a workflow",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateWorkflowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Workflow updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "summary": "Delete a workflow",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Workflow deleted",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "message"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/workflows/{id}/required-providers": {
      "get": {
        "summary": "Get required BYOK providers for a workflow",
        "description": "Analyzes the workflow DAG to extract all http.call endpoints, then queries key-service to determine which external providers (and their API keys) are needed to execute the workflow.",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Provider requirements",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderRequirementsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Workflow not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "502": {
            "description": "Key service unavailable or returned an error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflows/{id}/validate": {
      "post": {
        "summary": "Validate a workflow DAG",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationResult"
                }
              }
            }
          }
        }
      }
    },
    "/workflows/{id}/execute": {
      "post": {
        "summary": "Execute a workflow",
        "tags": [
          "Workflow Runs"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteWorkflowRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Execution started",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowRunResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflow-runs/{id}": {
      "get": {
        "summary": "Get a workflow run",
        "description": "Returns the current status and result of a workflow execution. If still running, polls the engine for the latest status before responding.",
        "tags": [
          "Workflow Runs"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Workflow run",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowRunResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflow-runs/{id}/debug": {
      "get": {
        "summary": "Debug a workflow run",
        "description": "Returns per-step execution details from the Windmill engine, including resolved inputs and outputs for each module. Use this to diagnose runtime issues that aren't visible in the final result.",
        "tags": [
          "Workflow Runs"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Debug details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowRunDebugResponse"
                }
              }
            }
          },
          "404": {
            "description": "Run not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflow-runs": {
      "get": {
        "summary": "List workflow runs",
        "tags": [
          "Workflow Runs"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": false,
            "name": "workflowId",
            "in": "query"
          },
          {
            "schema": {
              "type": "string"
            },
            "required": false,
            "name": "orgId",
            "in": "query"
          },
          {
            "schema": {
              "type": "string"
            },
            "required": false,
            "name": "campaignId",
            "in": "query"
          },
          {
            "schema": {
              "type": "string"
            },
            "required": false,
            "name": "status",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "List of runs",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "workflowRuns": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/WorkflowRunResponse"
                      }
                    }
                  },
                  "required": [
                    "workflowRuns"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/workflow-runs/{id}/cancel": {
      "post": {
        "summary": "Cancel a workflow run",
        "tags": [
          "Workflow Runs"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Run cancelled",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowRunResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflows/deploy": {
      "put": {
        "summary": "Deploy (upsert) workflows by DAG signature",
        "description": "Idempotent: creates new workflows or updates existing ones matched by (appId + DAG signature). The workflow name is auto-generated as {category}-{channel}-{audienceType}-{signatureName}. signatureName is a human-readable word auto-assigned to each unique DAG. After deploying, execute workflows via POST /workflows/by-name/{name}/execute.",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeployWorkflowsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Workflows deployed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeployWorkflowsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Validation error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflows/generate": {
      "post": {
        "summary": "Generate a workflow from natural language",
        "description": "Uses an LLM (Claude) to transform a natural language description into a valid DAG workflow. Validates the generated DAG and deploys it automatically. Returns the deployed workflow metadata along with the generated DAG.",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateWorkflowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Workflow generated and deployed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateWorkflowResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "LLM generated an invalid DAG that could not be fixed after retries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflows/best": {
      "get": {
        "summary": "Get the best-performing workflow by cost-per-outcome",
        "description": "Returns the single best workflow for the given category/channel/audienceType, ranked by lowest cost-per-reply or cost-per-click. Uses run cost data from runs-service and email engagement stats from email-gateway-service.",
        "tags": [
          "Workflows"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string",
              "minLength": 1,
              "description": "Application identifier. Required to scope the query."
            },
            "required": true,
            "description": "Application identifier. Required to scope the query.",
            "name": "appId",
            "in": "query"
          },
          {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/WorkflowCategory"
                },
                {
                  "description": "Filter workflows by category."
                }
              ]
            },
            "required": true,
            "description": "Filter workflows by category.",
            "name": "category",
            "in": "query"
          },
          {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/WorkflowChannel"
                },
                {
                  "description": "Filter workflows by channel."
                }
              ]
            },
            "required": true,
            "description": "Filter workflows by channel.",
            "name": "channel",
            "in": "query"
          },
          {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/WorkflowAudienceType"
                },
                {
                  "description": "Filter workflows by audience type."
                }
              ]
            },
            "required": true,
            "description": "Filter workflows by audience type.",
            "name": "audienceType",
            "in": "query"
          },
          {
            "schema": {
              "$ref": "#/components/schemas/BestWorkflowObjective"
            },
            "required": true,
            "description": "Which metric to optimize for.",
            "name": "objective",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Best workflow found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BestWorkflowResponse"
                }
              }
            }
          },
          "400": {
            "description": "Missing or invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "No workflows found matching the criteria or no completed runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "502": {
            "description": "External service (runs-service or email-gateway-service) unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/workflows/by-name/{name}/execute": {
      "post": {
        "summary": "Execute a workflow by name",
        "description": "Starts an async execution of a previously deployed workflow. Returns a run object with an ID — poll GET /workflow-runs/{id} for status (queued → running → completed/failed). Pass runtime data via inputs (accessible in nodes as $ref:flow_input.fieldName).",
        "tags": [
          "Workflow Runs"
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [
          {
            "schema": {
              "type": "string"
            },
            "required": true,
            "name": "name",
            "in": "path"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteByNameRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Execution started",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowRunResponse"
                }
              }
            }
          },
          "404": {
            "description": "Workflow not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/openapi.json": {
      "get": {
        "summary": "OpenAPI specification",
        "tags": [
          "Health"
        ],
        "responses": {
          "200": {
            "description": "OpenAPI spec",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true
                }
              }
            }
          }
        }
      }
    }
  }
}